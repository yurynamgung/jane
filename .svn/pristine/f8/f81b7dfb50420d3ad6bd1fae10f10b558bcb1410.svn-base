/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/* TODO: no class def error. looking at data instead of beetree (and Tree$Node instead of Tree)
 * run:
 * class beetree.BeeTreeGUI
 * Exception in thread "AWT-EventQueue-0" java.lang.NoClassDefFoundError: beetree/Tree$Node (wrong name: data/Tree$Node)
 */


package beetree;

//import beetree.BeeTree;
//import beetree.Tree;
import java.awt.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.util.ArrayList;
import java.util.Collections;
import java.awt.geom.Line2D;
import java.io.*;


/**
 *
 * @author beametitiri
 */

public class BeePanel extends JPanel implements MouseListener, MouseMotionListener {
    

    /**
     * 
     */
    public final static int CLEAR_STATE = 0;
    /**
     * 
     */
    public final static int NODE_STATE = 1;
    /**
     * 
     */
    public final static int ERASE_STATE = 2;
    /**
     * 
     */
    public final static int LINK_STATE = 3;
    /**
     * 
     */
    public final static int LABEL_STATE = 4;
    /**
     * 
     */
    public final static int TIME_STATE = 5;
    /**
     * 
     */
    public final static int REGION_STATE = 6;

    private BeeTree frame = null;
    private Tree host = null;
    private Tree parasite = null;
    private int state = -1;
    private static int radius = 5;  //pixel radius of nodes
    private boolean linking = false;
    private boolean dragging = false;
    private Tree.Node link1;
    private ArrayList<Tree.Node> links = new ArrayList<>();
    private ArrayList<Float> timeBorders = new ArrayList<>();
    private ArrayList<ArrayList<Double>> regionCosts = new ArrayList<ArrayList<Double>>();
    private int prevWidth = 0; //width before resize
    private int panelDisp = 30; //panel displacement due to descriptions of states and region key
    
    private Tree.Node grabbedNode;
    private Tree.Node grabbedArrow;
    private int arrowHead; //position of arrow head when dragging arrow
    private float grabbedBorder = -1;
    private int borderIndex = -1; //index of grabbedBorder
    private int dragX = -1; //x position of link when dragging
    private int dragY = -1; //y position of link when dragging
    private int clickedX = -1;
    private int clickedY = -1;

    /**
     * 
     */
    @SuppressWarnings("LeakingThisInConstructor")
    public BeePanel() {
        
        this.setBackground(Color.WHITE);
        
        addMouseListener(this);
        addMouseMotionListener(this);

    }
    
    /**
     * 
     * @param f
     */
    public void setFrame(BeeTree f) {
        frame = f;
    }

    /**
     * State affects which buttons are depressed. Depressed buttons are darkly shaded
     * @param newstate
     */
    public void setState(int newstate) {

        //unhighlight old state's button
        if (state == CLEAR_STATE) {
            frame.releaseClear();
        }
        else if(state == NODE_STATE) {
            frame.releaseNode();
        }
        else if(state == ERASE_STATE) {
            frame.releaseErase();
        }
        else if(state == LINK_STATE) {
            frame.releaseLink();
        }
        else if(state == LABEL_STATE) {
            frame.releaseLabel();
        }
         else if(state == TIME_STATE) {
            frame.releaseTime();
        }
        else if(state == REGION_STATE) {
            frame.releaseRegion();
        }

        //change state
        state = newstate;

        //highlight new state's button
        if (state == CLEAR_STATE) {
            frame.pressClear();
        }
        else if(state == NODE_STATE) {
            frame.pressNode();
        }
        else if(state == ERASE_STATE) {
            frame.pressErase();
        }
        else if(state == LINK_STATE) {
            frame.pressLink();
        }
        else if(state == LABEL_STATE) {
            frame.pressLabel();
        }
        else if(state == TIME_STATE) {
            frame.pressTime();
        }
        else if(state == REGION_STATE) {
            frame.pressRegion();
        }

        redoPanel();
    }


    /**
     * clears host tree after warning
     */
    public void clearHost() {
        int answer = 0;
        if (host != null && host.getNodes().size() > 1) {
                    answer = JOptionPane.showConfirmDialog(null,
                            "Are you sure you want to clear this tree?",
                            "Confirm clear", JOptionPane.YES_NO_OPTION);
                }
                if (answer == JOptionPane.YES_OPTION) {
                    host = new Tree(0, 0, getWidth()/2-5, getHeight(), Tree.HOST_TYPE);
                }
    }
    
    /**
     * clears parasite tree after warning
     */
    public void clearParasite() {
        int answer = 0;
        if (parasite != null && parasite.getNodes().size() > 1) {
                    answer = JOptionPane.showConfirmDialog(null,
                            "Are you sure you want to clear this tree?",
                            "Confirm clear", JOptionPane.YES_NO_OPTION);
                }
                if (answer == JOptionPane.YES_OPTION) {
                    parasite = new Tree(getWidth()/2+5, 0, getWidth()/2-5, getHeight(),
                            Tree.PARASITE_TYPE);
                }
    }
    /**
     * Used to add roots, add children, erase nodes, and label nodes.
     * @param e
     */
    public void mouseClicked(MouseEvent e) {
    /** Determines the action to be taken upon a mouse click based on the state
     of the panel */
        int x = e.getX();
        int y = e.getY()-panelDisp;
        //System.out.println("clicked x: " + x + ", y: " + e.getY());
        
        if (state == CLEAR_STATE) {
            //if clicking on left half
            if (x < getWidth()/2) {
                clearHost();
            }
            else if (x > getWidth()/2) {
                clearParasite();
            }
            
            links = new ArrayList<Tree.Node>();
            redoPanel();
        }
        else if (state == NODE_STATE) {
            addChildNode(x, y);
        }
        else if (state == ERASE_STATE) {
            removeNode(x, y);
            removeLink(x, y);
            removeTime(x, y);
        }
        else if (state == LABEL_STATE) {
            labelNode(x, y);
        }
        else if (state == LINK_STATE) {
            processLink(x,y);
        }
        else if (state == REGION_STATE && e.getY() > 30 && e.getY() < panelDisp) {
            editCosts();
        }
    }

    /**
     * Used for linking and editing timings 
     * @param e
     */
    public void mousePressed(MouseEvent e) {
    /** If we are in link mode, pass coordinates to link processor to start
     making a link between nodes*/
        //System.out.println("pressed");
        dragging = true;
        int x = e.getX();
        int y = e.getY()-panelDisp;
        
        if (state == LINK_STATE) {
            processLink(x,y);
        }
        
        if (state == TIME_STATE) {
            
            Tree.Node pressedNode = findNode(x, y);
            if (pressedNode != null)
            {
                if (pressedNode.getType() == Tree.INTERNAL_TYPE)
                    grabbedNode = pressedNode;
            }
            
            Tree.Node pressedArrow = findArrow(x, y);
            if (pressedArrow != null)
            {
                grabbedArrow = pressedArrow;   
                arrowHead = x;
            }
            
            int pressedBorder = findBorder(x, y);
            if (pressedBorder != -1)
            {
                grabbedBorder = pressedBorder;
            }
        }
        clickedX = x;
        clickedY = e.getY();
        redoPanel(); 
    }

    /**
     * Releasing finishes the linking between two nodes
     * @param e
     */
    public void mouseReleased(MouseEvent e) {
    /** If we are in link mode, pass coordinates to link processor */
        dragging = false;
        int x = e.getX();
        int y = e.getY()-panelDisp;
        
        if (state == LINK_STATE) {
            processLink(x,y);
        }
        
        if (state ==REGION_STATE && dragX != -1) {  
            processRegion();
        }
                
        grabbedNode = null;
        grabbedArrow = null;
        grabbedBorder = -1;
        dragX = -1;
        dragY = -1;   
        clickedX = -1;
        clickedY = -1;
        redoPanel();
    }

    /**
     * Dragging nodes, time zone borders, or node arrows    
     */
    public void mouseDragged(MouseEvent e) { 
        int x = e.getX();
        int y = e.getY()-panelDisp;
        
        if (state == TIME_STATE && !timeBorders.isEmpty())
        {
            if (grabbedNode != null)
                dragNode(x, y);
                
            else if (grabbedArrow != null)
                dragArrow(x, y);
            
            else if (grabbedBorder > 0)
                dragBorder(x, y);
            Collections.sort(timeBorders);
        }

        dragX = x;
        dragY = e.getY();        
        
        redoPanel();
    }
    
    /*
     * node dragging (to change time zone)
     */
    private void dragNode(int x, int y)
    {
        // dragging internal host node (not past its parent or children)
        if (x > 15 && x < getWidth()/2-20 
                && (grabbedNode.getParent().getMaxTime() == 1 || x > grabbedNode.getParent().getX())
                && (minChildTime(grabbedNode) == timeBorders.size()+1 || x < grabbedNode.getClosest().getX()))
        {
            grabbedNode.setX(x);

            //zone 1
            if (x < timeBorders.get(0))
            {
                grabbedNode.setMinTime(1);
                grabbedNode.setMaxTime(1);
            }

            //last zone
            else if (x > timeBorders.get(timeBorders.size()/2-1))
            {
                grabbedNode.setMinTime(timeBorders.size()/2+1);
                grabbedNode.setMaxTime(timeBorders.size()/2+1);
            }

            //any middle zone
            else
            {
                for (int i=0; i<timeBorders.size()-1; i++)
                {
                    if (x > timeBorders.get(i) && x < timeBorders.get(i+1))
                    {
                        grabbedNode.setMinTime(i+2);
                        grabbedNode.setMaxTime(i+2);
                    }
                }
            }
        }

        // dragging internal parasite node (not past its parent or children)
        else if (x > getWidth()/2 + 20 && x < getWidth()-15 
                && (grabbedNode.getParent().getMaxTime() == 1 || x < grabbedNode.getParent().getX())
                && (minChildTime(grabbedNode) == timeBorders.size()+1 || x > grabbedNode.getClosest().getX()))
        {
            grabbedNode.setX(x);

            //zone 1
            if (x > getWidth()-timeBorders.get(0))
            {
                grabbedNode.setMinTime(1);
                grabbedNode.setMaxTime(1);
            }

            //last zone
            else if (x < timeBorders.get(timeBorders.size()/2))
            {
                grabbedNode.setMinTime(timeBorders.size()/2+1);
                grabbedNode.setMaxTime(timeBorders.size()/2+1);
            }

            //any middle zone
            else
            {
                for (int i=timeBorders.size()/2; i<timeBorders.size()-1; i++)
                {
                    if (x > timeBorders.get(i) && x < timeBorders.get(i+1))
                    {
                        grabbedNode.setMinTime(timeBorders.size()-i);
                        grabbedNode.setMaxTime(timeBorders.size()-i);
                    }
                }
            }
        }
    }
    
    /*
     * arrow dragging
     */
    private void dragArrow(int x, int y)
    {
        //dragging host node arrow
        if (x < getWidth()/2)
        {
            boolean inBounds = true;
            for (Tree.Node child : grabbedArrow.getChildren())
            {
                if (x > timeBorders.get(child.getMaxTime()-1)-15)
                        inBounds = false;
            }

            //dragging right arrow to allowed spot
            if (x > grabbedArrow.getX()+10 && inBounds)
            {
                arrowHead = x;

                //zone 1
                if (x < timeBorders.get(0))
                    grabbedArrow.setMaxTime(1);

                //last zone
                if (x > timeBorders.get(timeBorders.size()/2-1))
                    grabbedArrow.setMaxTime(timeBorders.size()/2+1);

                //any middle zone
                else
                {
                    for (int i=0; i<timeBorders.size()/2-1; i++)
                    {
                        if (x > timeBorders.get(i) && x < timeBorders.get(i+1))
                            grabbedArrow.setMaxTime(i+2);
                    }
                }
            }

            //dragging left arrow to allowed spot
            else if (x < grabbedArrow.getX()-10 
                    && x > 15
                    && (grabbedArrow.getParent().getMinTime() == 1 
                        || x > timeBorders.get(grabbedArrow.getParent().getMinTime()-2)+15))
            { 
                arrowHead = x;
                //zone 1
                if (x < timeBorders.get(0))
                    grabbedArrow.setMinTime(1);

                //last zone
                if (x > timeBorders.get(timeBorders.size()/2-1))
                    grabbedArrow.setMinTime(timeBorders.size()/2+1);

                //any middle zone
                else
                {
                    for (int i=0; i<timeBorders.size()/2-1; i++)
                    {
                        if (x > timeBorders.get(i) && x < timeBorders.get(i+1))
                            grabbedArrow.setMinTime(i+2);
                    }
                }
            }
        }

        //dragging parasite node arrow
        else if (x > getWidth()/2)
        {
            boolean inBounds = true;
            for (Tree.Node child : grabbedArrow.getChildren())
            {
                if (x < timeBorders.get(timeBorders.size()-child.getMaxTime())+15)
                        inBounds = false;
            }

            //dragging left arrow to allowed spot
            if (x < grabbedArrow.getX()-10 && inBounds)
            {
                arrowHead = x;

                //zone 1
                if (x > timeBorders.get(timeBorders.size()-1))
                    grabbedArrow.setMaxTime(1);

                //last zone
                if (x < timeBorders.get(timeBorders.size()/2))
                    grabbedArrow.setMaxTime(timeBorders.size()/2+1);

                //any middle zone
                else
                {
                    for (int i=0; i<timeBorders.size()/2-1; i++)
                    {
                        if (x < timeBorders.get(timeBorders.size()-i-1) && x > timeBorders.get(timeBorders.size()-i-2))
                            grabbedArrow.setMaxTime(i+2);
                    }
                }
            }

            //dragging right arrow to allowed spot
            else if (x > grabbedArrow.getX()+10 
                    && x < getWidth()-15
                    && (grabbedArrow.getParent().getMinTime() == 1 
                        || x < timeBorders.get(timeBorders.size()-grabbedArrow.getParent().getMinTime()+1)-15))
            { 
                arrowHead = x;
                //zone 1
                if (x > timeBorders.get(timeBorders.size()-1))
                    grabbedArrow.setMinTime(1);

                //last zone
                if (x < timeBorders.get(timeBorders.size()/2-1))
                    grabbedArrow.setMinTime(timeBorders.size()/2+1);

                //any middle zone
                else
                {
                    for (int i=0; i<timeBorders.size()/2-1; i++)
                    {
                        if (x < timeBorders.get(timeBorders.size()-i-1) && x > timeBorders.get(timeBorders.size()-i-2))
                            grabbedArrow.setMinTime(i+2);
                    }
                }
            }
        }
    }
    
    /*
     * time zone border dragging
     */
    private void dragBorder(int x, int y)
    {
        // dragging host time zone border (not past adjacent time zone borders or midline)
        if (findBorder(x, y) != -1 && findBorder(x, y) < getWidth()/2)
        {
            grabbedBorder = findBorder(x, y);
            borderIndex = timeBorders.indexOf(grabbedBorder);
            System.out.println("borderIndex = " + borderIndex);
            if ((borderIndex == 0 || x > timeBorders.get(borderIndex-1)+60) 
                    && (borderIndex == timeBorders.size()/2-1 || x < timeBorders.get(borderIndex+1)-60)
                    && x < getWidth()/2-45
                    && x > 45)
            {
                timeBorders.set(borderIndex, (float)x);     
                for (Tree.Node node : host.getNodes())
                {
                    //if time zone border moved to the right past a node, change node's time zone
                    if (node.getMinTime() == borderIndex+2 && node.getMaxTime() == borderIndex+2 && x > node.getX())
                    {
                        node.setMinTime(borderIndex+1);
                        node.setMaxTime(borderIndex+1);
                    }   

                    //if time zone border moved to the left past a node, change node's time zone
                    if (node.getMinTime() == borderIndex+1 && node.getMaxTime() == borderIndex+1 && x < node.getX())
                    {
                        node.setMinTime(borderIndex+2);
                        node.setMaxTime(borderIndex+2);
                    }
                }
            }
        }

        // dragging parasite time zone border (not past adjacent time zone borders or midline)
        else if (grabbedBorder > getWidth()/2 && findBorder(x, y) != -1)
        {
            grabbedBorder = findBorder(x, y);
            borderIndex = timeBorders.indexOf(grabbedBorder);
            if ((borderIndex == timeBorders.size()/2 || x > timeBorders.get(borderIndex-1)+60)
                    && (borderIndex == timeBorders.size()-1 || x < timeBorders.get(borderIndex+1)-60)
                    && x > getWidth()/2+45
                    && x < getWidth()-45)
                timeBorders.set(borderIndex, (float)x);
            for (Tree.Node node : parasite.getNodes())
            {
                //if time zone border moved to the right past a node, change node's time zone
                if (node.getMinTime() == timeBorders.size()-borderIndex+1 && node.getMaxTime() == timeBorders.size() -borderIndex+1 && x < node.getX())
                {
                    node.setMinTime(timeBorders.size()-borderIndex);
                    node.setMaxTime(timeBorders.size()-borderIndex);
                }   

                //if time zone border moved to the left past a node, change node's time zone
                if (node.getMinTime() == timeBorders.size()-borderIndex && node.getMaxTime() == timeBorders.size()-borderIndex && x > node.getX())
                {
                    node.setMinTime(timeBorders.size()-borderIndex+1);
                    node.setMaxTime(timeBorders.size()-borderIndex+1);
                }
            }
        }
    }
    
    
    /**
     * 
     * @param e
     */
    public void mouseMoved   (MouseEvent e) {
        /*
         * sets cursor to hand if hovering over place to click
         */
        int x = e.getX();
        int y = e.getY()-panelDisp;
        
        if (state == NODE_STATE)
        {
            if (findNode(x, y) != null)
                this.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            else
                this.setCursor(Cursor.getDefaultCursor());
        }
        
        if (state == ERASE_STATE)
        {
            if (findNode(x, y) != null && findNode(x, y) != host.getRoot() && findNode(x, y) != parasite.getRoot())
                this.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            else if (findLink(x, y) != null)
                this.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            else if (findBorder(x, y) != -1)
                this.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            else
                this.setCursor(Cursor.getDefaultCursor());
        }
        
        if (state == LABEL_STATE)
        {
            if (findNode(x, y) != null)
            {
                Tree.Node node = findNode(x, y);
                if (node.getType() == Tree.LEAF_TYPE)
                    this.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
                else
                    this.setCursor(Cursor.getDefaultCursor());
            }
            else
                this.setCursor(Cursor.getDefaultCursor());
        }
        
        if (state == LINK_STATE)
        {
            if (findNode(x, y) != null)
            {
                Tree.Node node = findNode(x, y);
                if (node.getType() == Tree.LEAF_TYPE)
                {
                    if (linking)
                    {
                        if (link1.getX() < getWidth()/2) //can only link to node on parasite tree
                        {
                            if (x > getWidth()/2) 
                                this.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
                            else
                                this.setCursor(Cursor.getDefaultCursor());
                        }
                        else //can only link to node on host tree
                        {
                            if (x < getWidth()/2) 
                                this.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
                            else
                                this.setCursor(Cursor.getDefaultCursor());
                        }
                    }
                    else //not linking
                        this.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
                }
                else //not leaf
                    this.setCursor(Cursor.getDefaultCursor());
            }
            else //not node
                this.setCursor(Cursor.getDefaultCursor());
        }
        
        if (state == TIME_STATE)
        {
            if (findNode(x, y) != null)
            {
                Tree.Node node = findNode(x, y);
                if (node.getType() == Tree.INTERNAL_TYPE)
                    this.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
                else
                    this.setCursor(Cursor.getDefaultCursor());
            }
            
            else if (findBorder(x, y) != -1)
                this.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            
            else if (findArrow(x, y) != null)
                this.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            
            else
                this.setCursor(Cursor.getDefaultCursor());
        }
        
        if (state == CLEAR_STATE)
        {
            if (y>0)
                this.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            else
                this.setCursor(Cursor.getDefaultCursor());
        }
        
        if (state == REGION_STATE) 
        {
            if (e.getY() > 30 && e.getY() < panelDisp)
                this.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
            else 
                this.setCursor(Cursor.getDefaultCursor());
        }
    }
                    
                        
                  
    /**
     * 
     * @param e
     */
    public void mouseEntered (MouseEvent e) {
    }  
    
    /**
     * 
     * @param e
     */
    public void mouseExited  (MouseEvent e) {
    }  
    
    /*
     * returns minimum time zone of children of node
     */
    private int minChildTime(Tree.Node node)
    {
        int minTime = 9999;
        for (Tree.Node child : node.getChildren())
        {
            int childTime = child.getMinTime();
            if (childTime < minTime)
                minTime = childTime;
        }
        return minTime;      
    }  
    
/*
 * labels node (only leaves can have labels)
 */
    private void labelNode(int x, int y) {
        if (findNode(x, y) != null)
        {
            Tree.Node labelee = findNode(x, y);
            if (labelee.getChildren().size() == 0)
            {
                String labelStr = "";
                boolean validInput = false;
                while (validInput == false)
                {
                    labelStr = JOptionPane.showInputDialog("Enter Label: ");
                    try
                    {
                        Integer.parseInt(labelStr);
                        JOptionPane.showConfirmDialog(null, "Integer labels are not permitted", "Integer warning", JOptionPane.DEFAULT_OPTION);
                    }
                    catch (NumberFormatException nfe)
                    {
                        labelee.setLabel(labelStr);
                        validInput = true;
                    }
                }
            }
            redoPanel();
        }

    }

    /*
     * Checks for the existence of a node at the coordinates given. If in linking
     * state, then link appropriately.
     */
    private void processLink(int x, int y) {
    /** If we have not started a link, check for node at given position and start
     a link if one is there. If we have started a link, check for a node at the
     given position and complete the link if one's there, otherwise stop linking*/

        Tree.Node clicked = findNode(x,y);

        if (!linking) {
            if (clicked != null && clicked.getType() == Tree.LEAF_TYPE) {
                linking = true;
                link1 = clicked;
            }
        }
        
        else {
            
            if (clicked != null && clicked.getType() == Tree.LEAF_TYPE &&
                    getSide(clicked.getX()) != getSide(link1.getX())) {
                for (Tree.Node linkedNode : link1.getLink())
                {
                    
                    if (linkedNode == clicked) //trying to draw already present link
                    {
                        link1 = null;    
                        linking = false;
                        redoPanel();
                        return;
                    }
                }
                
                link1.addLink(clicked);
                clicked.addLink(link1);
                boolean contains = false;
                if (link1.getTreeType() == Tree.HOST_TYPE)
                {
                    for (Tree.Node linkedNode : links)
                    {
                        if (link1 == linkedNode)
                            contains = true;
                    }
                    if (!contains)
                        links.add(link1);
                }
                else
                {
                    for (Tree.Node linkedNode : links)
                    {
                        if (clicked == linkedNode)
                            contains = true;
                    }
                    if (!contains)
                        links.add(clicked);
                }
            }
            
            linking = false;
            link1 = null;
            redoPanel();
        }

    }
    
    
    /*
     * user sets region of selected nodes
     */
    private void processRegion()
    {
        ArrayList<Tree.Node> selected = new ArrayList<Tree.Node>();
        for (Tree.Node node : host.getNodes())
        {
            int nodeY = node.getY()+panelDisp;
            System.out.println("clickedX = " + clickedX);
            System.out.println("dragX = " + dragX);
            System.out.println("clickedY = " + clickedY);
            System.out.println("dragY = " + dragY);
            if (((node.getX() > clickedX && node.getX() < dragX) || (node.getX() < clickedX && node.getX() > dragX))
                    && ((nodeY > clickedY && nodeY < dragY) || (nodeY < clickedY && nodeY > dragY)))
            {
                selected.add(node);
            }
        }
        System.out.println("selected = " + selected);
        
        if (!selected.isEmpty())
        {
            int regNum = 0;
            boolean validInput = false;
            while (validInput == false)
            {
                JPanel regPanel = new JPanel();
                regPanel.setLayout(new BoxLayout(regPanel, BoxLayout.Y_AXIS));
                regPanel.add(new JLabel("Region Number:"));
                JTextField regionNum = new JTextField();
                regPanel.add(regionNum, Component.LEFT_ALIGNMENT);
                JLabel note = new JLabel("Note: either all host nodes must be assigned to nonzero");
                regPanel.add(note);
                JLabel noteln = new JLabel("regions or all must be assigned to region 0 (default setting).");
                regPanel.add(noteln);
                
                int result = JOptionPane.showConfirmDialog(null, regPanel, "", JOptionPane.OK_CANCEL_OPTION);
                 
                if (result == JOptionPane.OK_OPTION) {
                    if (regionNum.getText().trim().length() > 0)
                    {
                        try
                        {
                            String rNum = regionNum.getText();
                            regNum = Integer.parseInt(rNum);

                            if (regNum < 0)
                            {
                                JOptionPane.showConfirmDialog(null, "Enter a nonnegative integer", "Invalid integer warning", JOptionPane.DEFAULT_OPTION);
                            }

                            else
                            {
                                validInput = true;
                            }
                        }

                        catch(NumberFormatException nfe)
                        {
                            JOptionPane.showConfirmDialog(null, "Enter an integer", "Non-integer warning", JOptionPane.DEFAULT_OPTION);
                        }
                    }

                    else
                        return;
                }
                else
                    return;

                for (Tree.Node select : selected)
                {
                    select.setRegion(regNum);
                }
            }
        }
    }
    
    /* if the given point is contained by a node, a child will be added to
     * that node, otherwise nothing will be done
     */
    private void addChildNode(int x, int y) 
    {

        Tree.Node clicked = findNode(x, y);

        if (clicked != null) 
        {
            if (clicked.getLink()!=null) 
            {
                for (Tree.Node linkedNode : clicked.getLink())
                {
                    linkedNode.getLink().remove(clicked);
                    if (linkedNode.getLink() == null)
                        links.remove(linkedNode);
                }
                links.remove(clicked);
                clicked.setLink(null);
            }
            int side = getSide(x);
            
            Tree.Node newkid;
            
            if (side == Tree.HOST_TYPE) {
                host.addChild(clicked);
                newkid = clicked.getLastChild();
                setLeafTime(newkid);        
                if (clicked.getChildren().size() == 1)
                    host.addChild(clicked);
                    newkid = clicked.getLastChild();
                    setLeafTime(newkid);        
            }
            
            else {
                parasite.addChild(clicked); 
                newkid = clicked.getLastChild();
                setLeafTime(newkid);       
                if (clicked.getChildren().size() == 1)
                    parasite.addChild(clicked); 
                    newkid = clicked.getLastChild();
                    setLeafTime(newkid);       
            }
            
            redoPanel();
        }
    }
    
    /*
     * sets leaf to be in highest time zone
     */
    private void setLeafTime(Tree.Node leaf)
    {
        int leafTime = 1;
        if (!timeBorders.isEmpty())
            leafTime = timeBorders.size()/2+1;
        leaf.setMinTime(leafTime);
        leaf.setMaxTime(leafTime);
    }
            

    private void removeNode(int x, int y) {
    /** Removes the node at the given point (if there is one) and all its children */
        Tree.Node clicked = findNode(x, y);

        if (clicked != null) 
        {
            removeChildLinks(clicked);
            
            int side = getSide(x);
            if (side == Tree.HOST_TYPE) 
                host.removeChild(clicked);
            else 
                parasite.removeChild(clicked);

            redoPanel();
        }
    }
    
    private void removeChildLinks(Tree.Node node) {
        /*
         * removes all links in nodes subtree
         */
        if (node.getChildren().isEmpty())
        {
            if (node.getLink() != null)
            {
                links.remove(node);
                for (Tree.Node linkedNode : node.getLink())
                {
                    linkedNode.getLink().remove(node);
                    if (linkedNode.getLink().isEmpty())
                    {
                        links.remove(linkedNode);
                    }
                }
                node.setLink(null);
            }
        }
        else
        {
            for (Tree.Node child : node.getChildren())
                removeChildLinks(child);
        }
    }
    
    private void removeLink(int x, int y) { 
        /*
         * removes link at given point (if there is one)
         */
        if (findLink(x, y) != null)
        {
            ArrayList<Tree.Node> clickedLink = findLink(x, y);
            if (!clickedLink.isEmpty())
            {
                Tree.Node leaf = clickedLink.get(0);
                Tree.Node leafLink = clickedLink.get(1);
                leaf.getLink().remove(leafLink);
                leafLink.getLink().remove(leaf);
                if (leaf.getLink().isEmpty())
                    links.remove(leaf);
                if (leafLink.getLink().isEmpty())
                    links.remove(leafLink); 
            }
            redoPanel();
        }
    }
    
    private void removeTime(int x, int y) {
        /*
         * removes timing information
         */
        if (findBorder(x, y) != -1)
        {
            int answer = JOptionPane.showConfirmDialog(null,
                            "Are you sure you want to remove all timing information?",
                            "Confirm remove time", JOptionPane.YES_NO_OPTION);
            
            if (answer == JOptionPane.YES_OPTION) {
                for (Tree.Node node : host.getNodes())
                {
                    node.setMinTime(1);
                    node.setMaxTime(1);
                }
                for (Tree.Node node : parasite.getNodes())
                {
                    node.setMinTime(1);
                    node.setMaxTime(1);
                }
                timeBorders.clear();
                redoPanel();
            }
        }
    }
    
    private void editCosts() {
        /*
         * user inputs region costs
         */
        
        boolean validInput = false;
        while (validInput == false)
        {
                JPanel costPanel = new JPanel();
                costPanel.setLayout(new BoxLayout(costPanel, BoxLayout.Y_AXIS));
                costPanel.add(new JLabel("From region: "));
                JTextField startReg = new JTextField();
                costPanel.add(startReg);
                costPanel.add(new JLabel("to region: "));
                JTextField endReg = new JTextField();
                costPanel.add(endReg);
                costPanel.add(new JLabel("Cost: "));
                JTextField cost = new JTextField();
                costPanel.add(cost);
                costPanel.add(new JLabel("Note: A cost of i means host switch not allowed"));
                
                int result = JOptionPane.showOptionDialog(null, costPanel, "", JOptionPane.DEFAULT_OPTION, JOptionPane.PLAIN_MESSAGE, null, new String[] {"Finish", "Add Another", "Cancel"}, "");
                
                int startInt;
                int endInt;
                double startNum;
                double endNum;
                double costNum;
                
                if (result == 2)
                    return;
                else if (result == 0 || result == 1)
                {
                    try
                    {
                        String startStr = startReg.getText();
                        startInt = Integer.parseInt(startStr);
                        if (hasRegion(startInt))
                            startNum = (double)startInt;
                        else
                            startNum = Double.valueOf("s").doubleValue();
                        
                        String endStr = endReg.getText();
                        endInt = Integer.parseInt(endStr);
                        if (hasRegion(endInt))
                        {
                            endNum = (double)endInt;
                        }
                        else
                            endNum = Double.valueOf("s").doubleValue();
                        
                        String costStr = cost.getText();
                        System.out.println("cost.getText() = " + cost.getText());
                        if (costStr.equals("i"))
                            costNum = Double.POSITIVE_INFINITY;
                        else if (costStr.equals("0"))
                            costNum = Double.valueOf("s").doubleValue();
                        else
                            costNum = Double.valueOf(costStr).doubleValue();
                        
                        ArrayList<Double> switchCost = new ArrayList<Double>();
                        switchCost.add(startNum);
                        switchCost.add(endNum);
                        switchCost.add(costNum);
                        
                        for (int i=0; i < regionCosts.size(); i++)
                        {
                            if (regionCosts.get(i).get(0)==startNum && regionCosts.get(i).get(1)==endNum)
                                regionCosts.remove(i);
                        }
                        
                        regionCosts.add(switchCost);
                        
                        if (result == 0)
                            validInput = true;
                    }
                    
                    catch(NumberFormatException nfe)
                    {
                        JOptionPane.showConfirmDialog(null, "Enter region numbers in first two fields and a nonzero integer or 'i' in last field", "Invalid input warning", JOptionPane.DEFAULT_OPTION);
                    }
                    
                    redoPanel();
                }
        }
    }
            
    
    private ArrayList<Tree.Node> findLink(int x, int y)  {
        /*
         * returns ArrayList of Tree.Nodes connected by clicked link
         */
        for (Tree.Node leaf : links) {
            //System.out.println("leafx: " + leaf.getX());
            
            float x1 = leaf.getX();
            float y1 = leaf.getY();
            for (Tree.Node leafLink : leaf.getLink())
            {
                float x2 = leafLink.getX();
                float y2 = leafLink.getY();
               
                if ((x > getWidth()/2 - 20 && x < getWidth()/2 + 20)) 
                {
                    float slope = (y2-y1)/(x2-x1);
                    float linky = y1 + slope * (x - x1);
                    if (y > linky - 15 && y < linky + 15) 
                    {
                        ArrayList<Tree.Node> clickedLink = new ArrayList<Tree.Node>();
                        clickedLink.add(leaf);
                        clickedLink.add(leafLink);
                        return clickedLink;
                    }
                }
            }
        }
        return null;
    }

    private int getSide(int x) {
    /** Given an x coordinate, returns whether it is on the host or
     * parasite side
     */
        if (x == getWidth()/2)
            return -1;
        if (x < getWidth()/2)
            return Tree.HOST_TYPE;
        else
            return Tree.PARASITE_TYPE;
    }

    private Tree.Node findNode(int x, int y) {
    /** Returns the node whose bounds contain the given point */
        Tree.Node clicked = null;
        Tree tree;
        int side = getSide(x);
        
        if (side == Tree.HOST_TYPE) {
            tree = host;
        }
        else if (side == Tree.PARASITE_TYPE){
            tree = parasite;
        }
        else  {
            return null;
        }

        if (tree != null) {
            for (int i=0; i < tree.getNodes().size(); i++) {
                clicked = tree.getNodes().get(i);
                if (x < (clicked.getX()+2.0*radius) && x > (clicked.getX()-2.0*radius)
                    && y < (clicked.getY()+2.0*radius) && y > (clicked.getY()-2.0*radius))
                    return clicked;
            }
        }
        
        return null;
    }
    
    
    private int findBorder(int x, int y) {
    /** returns x-coordinate of time zone border whose bounds contain given x */
        for (float timeBorder : timeBorders)
        {
            if (x < timeBorder+15 && x > timeBorder-15 && y>0)
                return (int)Math.round(timeBorder);
        }
        return -1;
    }

    
    private Tree.Node findArrow(int x, int y) {
    /** returns node whose arrow contains given point */
        //host tree arrows
        for (Tree.Node node : host.getNodes()) 
        {
            //node in only one time zone
            if ((node.getMinTime() == node.getMaxTime()) 
                    && ((x >= (node.getX()+10) && x < (node.getX()+20)) 
                        || (x <= (node.getX()-10) && x > (node.getX()-20)))
                    && (y < (node.getY()+10) && y > (node.getY()-10)))
            {
                    return node;
            }

            //range of time zones
            else if (node.getMinTime() != node.getMaxTime())
            {
                int minY = node.getY()-10;
                int maxY = node.getY()+10;
                
                //left arrow extends to root AND right arrow extends to leaves
                if (node.getMinTime() == 1 && node.getMaxTime() == timeBorders.size()/2+1)
                {
                    if ((x > 10 && x < 25)
                        || (x < getWidth()/2-15 && x > getWidth()/2-30))
                    {
                        return node;
                    }
                }

                else
                {
                    //left arrow extends to root
                    if (node.getMinTime() == 1
                            && ((x > 10 && x < 25)
                                || (x <= timeBorders.get(node.getMaxTime()-1)-15 && x > timeBorders.get(node.getMaxTime()-1)-30))
                            && (y < maxY && y > minY))
                    {
                        return node;
                    }

                    //right arrow extends to leaves
                    if (node.getMaxTime() == timeBorders.size()/2+1
                            && ((x < getWidth()/2-15 && x > getWidth()/2-30)
                                || (x >= timeBorders.get(node.getMinTime()-2)+15 && x < timeBorders.get(node.getMinTime()-2)+30))
                            && (y < maxY && y > minY))
                    {
                        return node;
                    }

                    //arrows span only internal time zones
                    if (node.getMinTime() != 1 && node.getMaxTime() != timeBorders.size()/2+1)
                    {
                        if (((x <= timeBorders.get(node.getMaxTime()-1)-15 && x > timeBorders.get(node.getMaxTime()-1)-30)
                                || (x >= timeBorders.get(node.getMinTime()-2)+15 && x < timeBorders.get(node.getMinTime()-2)+30))
                            && (y < node.getY()+10 && y > (node.getY()-10)))
                        {
                            return node;
                        }    
                    }
                }
            }
        }

        //parasite tree arrows
        for (Tree.Node node : parasite.getNodes()) 
        {
            //node in only one time zone
            if ((node.getMinTime() == node.getMaxTime()) 
                    && ((x >= (node.getX()+10) && x < (node.getX()+20)) 
                        || (x <= (node.getX()-10) && x > (node.getX()-20)))
                    && (y < (node.getY()+10) && y > (node.getY()-10)))
            {
                    return node;
            }

            //range of time zones
            else if (node.getMinTime() != node.getMaxTime())
            {
                int minY = node.getY()-10;
                int maxY = node.getY()+10;
                //right arrow extends to root AND left arrow extends to leaves
                if (node.getMinTime() == 1 && node.getMaxTime() == timeBorders.size()/2+1)
                {
                    if ((x < getWidth()-10 && x > getWidth()-25)
                        || (x > getWidth()/2+15 && x < getWidth()/2+30))
                    {
                        return node;
                    }
                }

                else
                {
                    //right arrow extends to root
                    if (node.getMinTime() == 1
                            && ((x < getWidth()-10 && x > getWidth()-25)
                                || (x >= timeBorders.get(timeBorders.size()-node.getMaxTime())+15 && x < timeBorders.get(timeBorders.size()-node.getMaxTime())+30))
                            && (y < maxY && y > minY))
                    {
                        return node;
                    }

                    //left arrow extends to leaves
                    if (node.getMaxTime() == timeBorders.size()/2+1
                            && ((x > getWidth()/2+15 && x < getWidth()/2+30)
                                || (x <= timeBorders.get(timeBorders.size()-node.getMinTime()+1)-15 && x > timeBorders.get(timeBorders.size()-node.getMinTime()+1)-30))
                            && (y < maxY && y > minY))
                    {
                        return node;
                    }

                    //arrows span only internal time zones
                    if (node.getMinTime() != 1 && node.getMaxTime() != timeBorders.size()/2+1)
                    {
                        if (((x >= timeBorders.get(timeBorders.size()-node.getMaxTime())+15 && x < timeBorders.get(timeBorders.size()-node.getMaxTime())+30)
                                || (x <= timeBorders.get(timeBorders.size()-node.getMinTime()+1)-15 && x > timeBorders.get(timeBorders.size()-node.getMinTime()+1)-30))
                            && (y < node.getY()+10 && y > (node.getY()-10)))
                        {
                            return node;
                        }    
                    }
                }
            }
        }
        return null;
    }
    

    /**
     * 
     * @param g
     */
    @Override
    protected void paintComponent(Graphics g) {
    /** Overrides JComponent's paintComponent function to paint trees */
        super.paintComponent(g);
        
        if (host == null)
        {
            host = new Tree(0, 0, getWidth()/2-5, getHeight(), Tree.HOST_TYPE);
        }
        
        if (parasite == null)
        {
            parasite = new Tree(0, 0, getWidth()/2-5, getHeight(), Tree.PARASITE_TYPE);
        }
        
        //draws background
        g.setColor(Color.WHITE);
        g.fillRect(0, 0, getWidth(), getHeight());
        g.setColor(Color.BLACK);
        g.drawLine(0, 30, getWidth(), 30);
        
        
        //writes state description
        if (state == NODE_STATE)
        {
            g.drawString("Add Child Mode - click any node", 20, 20);
        }
        if (state == LABEL_STATE)
        {
            g.drawString("Label Mode - click any leaf", 20, 20);
        }
        if (state == LINK_STATE)
        {
            g.drawString("Link Mode - drag between two leaves or click two leaves in succession to form link", 20, 20);
        }
        if (state == TIME_STATE)
        {
            g.drawString("Time Zone Mode - drag any internal node or time zone border to set time zone or drag arrows to set range of time zones", 20, 20);
        }
        if (state == REGION_STATE)
        {
            g.drawString("Region Mode - select host tree nodes to specify region or click the below region key to specify region switching costs. ", 20, 20); //change this
        }
        if (state == ERASE_STATE)
        {
            g.drawString("Erase Mode - click node or link to erase, or click time zone border to remove time zones", 20, 20);        
        }
        if (state == CLEAR_STATE)
        {
            g.drawString("Clear Mode - click either tree", 20, 20);
        }
        
        //draws region keys
        if (maxRegion() != 0)
        {
            drawRegKey(g);
            drawRegCostKey(g);   
            g.drawLine(0, panelDisp, getWidth(), panelDisp);
        }
        g.drawLine(getWidth()/2, panelDisp, getWidth()/2, getHeight());
            
        // sets coordinates of nodes and time zone borders before drawing
        if (!dragging)
        {
            scaleHostX();
            scaleHostY();
            scaleParasiteX();
            scaleParasiteY();
            scaleTimeBorders();
        }
        
        //draws linking between trees
        drawLinks(g);
        
        //draws host tree
        paintHelper(g, host.getRoot(), 0);
        
       //draws parasite tree 
        Tree.Node paraRoot = parasite.getRoot();
        paraRoot.setX(getWidth()-10); //reposition root if window resized
        paintHelper(g, paraRoot, getWidth());
         
        g.setColor(Color.RED);
        // draws time zone arrows
        drawArrows(g);
        //draws time zone borders
        drawZones(g);
    
        //draws selection box for selecting nodes in region mode
        g.setColor(Color.gray);
        drawBox(g);
    }
    
    
    /*
     * Sets x-coordinates of host tree nodes(supports window resize)
     */
    private void scaleHostX()
    {
        if (host != null)
        { 
            if (host.getLeaves().size() != 0)
            {
                 for (Tree.Node node : host.getNodes())
                 {
                    if (node.getChildren().isEmpty()) 
                    {
                         node.setX(getWidth()/2 - 20);
                    }
                    
                    else if (node.getParent() != null)
                    {
                        int depthSubtree = maxDepthSubtree(node); 
                        int avTime = (node.getMinTime()+node.getMaxTime())/2; //node's average time zone (rounded)
                        int highBound; //x-coord of time zone border, child, or panel divide that bounds node on right
                        
                        if (timeBorders.isEmpty() || avTime == timeBorders.size()/2+1)
                            highBound = getWidth()/2-20; 
                        else
                            highBound = (int)Math.round(timeBorders.get(avTime-1));
                        
                        int lowBound; //x-coord of time zone border, parent, or panel edge that bounds node on left
                        int childDist; //distance from lowBound to node
                        int avParTime = (node.getParent().getMinTime()+node.getParent().getMaxTime())/2; //parent's average time zone (rounded)
                        
                        if (avTime == avParTime)
                        {
                            lowBound = node.getParent().getX();
                            //bound by parent and midline
                            if (timeBorders.isEmpty() || avTime == timeBorders.size()/2+1)
                                childDist = ((highBound-lowBound)/(depthSubtree+1));
                            //bound by parent and time zone line
                            else
                                childDist = 2 * (highBound-lowBound)/(2*depthSubtree+3);
                        }
                        
                        else
                        {
                            if (avTime == 1)
                                lowBound = host.getRoot().getX();
                            else
                                lowBound = (int)Math.round(timeBorders.get(avTime-2));
                            //bound by time zone line (or root) and midline
                            if (avTime == timeBorders.size()/2+1)
                                childDist = (highBound - lowBound)/3;
                            //bound by two time zone lines
                            else
                                childDist = (highBound-lowBound)/(2*depthSubtree+2);
                        }
                        node.setX(lowBound + childDist);
                              
                    }
                 }
            }
        }
    }
        
    /*
     * sets y-coordinates of host nodes (supports window resize)
     */
    private void scaleHostY()
    {
        if (host != null)
        {
            host.getRoot().setY((getHeight()-panelDisp)/2);
            if (host.getLeaves().size() != 0)
            {
                int leafSep = (getHeight()-panelDisp) / host.getLeaves().size();
                for (int i=0; i<host.getLeaves().size(); i++)
                {
                    host.getLeaves().get(i).setY(leafSep/2 + leafSep * i);
                }
                int maxDepth = host.getMaxdepth(); 
                for (int i = maxDepth-1; i > 0; i--)
                {
                    for (Tree.Node node : host.getNodes()) 
                    {
                        if (node.getDepth() == i)
                        {
                            int maxChild;
                            
                            //if node's arrows could intersect another node
                            if (node.getChildren().size() % 2 == 1 
                                        && (node.getMinTime() != node.getMaxTime() || sameYChild(node)))
                            {
                                maxChild = node.getChildren().size() - 2;
                                node.setY((node.getChildren().get(0).getY() + node.getChildren().get(maxChild).getY())/2); 
                            }
                            
                            else if (node.getChildren().size() != 0)
                            {
                                maxChild = node.getChildren().size() - 1;
                                node.setY((node.getChildren().get(0).getY() + node.getChildren().get(maxChild).getY())/2);   
                            }
                        }
                    }
                }
            }
        }
    }
    
    /*
     * sets x-coordinates of parasite nodes (supports window resize)
     */
     private void scaleParasiteX()
     {
         if (parasite != null)
        { 
            if (parasite.getLeaves().size() != 0)
            {
                 for (Tree.Node node : parasite.getNodes())
                 {
                    if (node.getChildren().isEmpty()) 
                    {
                         node.setX(getWidth()/2 + 20);
                    }
                    
                    else if (node.getParent() != null)
                    {
                        int depthSubtree = maxDepthSubtree(node); 
                        int avTime = (node.getMinTime()+node.getMaxTime())/2; //node's average time zone (rounded)
                        int highBound; //x-coord of time zone border, child, or panel divide that bounds node on right
                        
                        if (timeBorders.isEmpty() || avTime == timeBorders.size()/2+1)
                            highBound = getWidth()/2+20; 
                        else
                            highBound = (int)Math.round(timeBorders.get(timeBorders.size()-avTime));
                        
                        int lowBound; //x-coord of time zone border, parent, or panel edge that bounds node on left
                        int childDist; //distance from lowBound to node
                        int avParTime = (node.getParent().getMinTime()+node.getParent().getMaxTime())/2; //parent's average time zone (rounded)
                        
                        if (avTime == avParTime)
                        {
                            lowBound = node.getParent().getX();
                            //bound by parent and midline
                            if (timeBorders.isEmpty() || avTime == timeBorders.size()/2+1)
                                childDist = ((lowBound-highBound)/(depthSubtree+1));
                            //bound by parent and time zone line
                            else
                                childDist = 2 * (lowBound-highBound)/(2*depthSubtree+3);
                        }
                        
                        else
                        {
                            if (avTime == 1)
                                lowBound = parasite.getRoot().getX();
                            else
                                lowBound = (int)Math.round(timeBorders.get(timeBorders.size()-avTime+1));
                            //bound by time zone line (or root) and midline
                            if (avTime == timeBorders.size()/2+1)
                                childDist = (lowBound-highBound)/3;
                            //bound by two time zone lines
                            else
                                childDist = (lowBound-highBound)/(2*depthSubtree+2);
                        }
                        node.setX(lowBound - childDist);
                              
                    }
                 }
            }
        }
    }
         
     
     /*
      * sets y-coordinates of parasite nodes (supports window resize
      */
     private void scaleParasiteY()
     {
         if (parasite != null)
         {
             parasite.getRoot().setY((getHeight()-panelDisp)/2);
             if (parasite.getLeaves().size() != 0)
             {
                    int leafSep = (getHeight()-panelDisp) / parasite.getLeaves().size();
                    for (int i=0; i<parasite.getLeaves().size(); i++)
                    {
                        parasite.getLeaves().get(i).setY(leafSep/2 + leafSep * i);
                    }
                    int maxDepth = parasite.getMaxdepth(); 
                    for (int i=maxDepth - 1; i >0; i--)
                    {
                        for (Tree.Node node : parasite.getNodes()) 
                        {
                            if (node.getDepth() == i)
                            {
                                int maxChild;
                                
                                //if node's arrows could intersect with another node
                                if (node.getChildren().size() % 2 == 1 
                                        && (node.getMinTime() != node.getMaxTime() || sameYChild(node)))
                                {
                                    maxChild = node.getChildren().size() - 2;
                                    node.setY((node.getChildren().get(0).getY() + node.getChildren().get(maxChild).getY())/2); 
                                }
                                
                                else if (node.getChildren().size() != 0)
                                {
                                    maxChild = node.getChildren().size() - 1;
                                    node.setY((node.getChildren().get(0).getY() + node.getChildren().get(maxChild).getY())/2);   
                                }
                                
                            }    
                        }
                    }
             }
         }
     }
     
     /*
      * sets x-coordinates of time zone borders (supports window resize)
      */
      private void scaleTimeBorders()
      {
            if (prevWidth == 0)
            {
                prevWidth = getWidth();
            }
            else
            {
                float scale = (float)getWidth()/(float)prevWidth;
                ArrayList<Float> newTimeBorders = new ArrayList<>();
                
                for (float timeBorder : timeBorders)
                {
                    float newTimeBorder = (timeBorder * scale);
                    newTimeBorders.add(newTimeBorder);                      
                }
                
                timeBorders = newTimeBorders;
                prevWidth = getWidth();
            }
          
      }
    
     
    /*
     * Returns maximum depth of subtree with given root considering ONLY nodes in same time zone
     */
    private int maxDepthSubtree(Tree.Node root) {
        if (root.getChildren().isEmpty())
        {
            return 0;
        }
        else
        {
            int maxDepth = 0;
            boolean timeChildren = false; // true if root has child in same time zone
            for (Tree.Node c : root.getChildren())
            {
                if (root.getMinTime() == c.getMinTime() && root.getMaxTime() == c.getMaxTime())
                {
                    timeChildren = true;
                    int maxDepthC = maxDepthSubtree(c);
                    if (maxDepthC > maxDepth)
                    {
                        maxDepth = maxDepthC;
                    }
                }
            }
            if (timeChildren)   
                return maxDepth + 1;
            else
                return 0;
        }
    }
    
    /*
     * returns true if node has a child with the same y coordinate and the child covers a range of time zones
     */
    private boolean sameYChild(Tree.Node node)
    {
        for (Tree.Node child : node.getChildren())
        {
            if (child.getY() == node.getY() && child.getMinTime() != child.getMaxTime())
                return true;     
        }
        return false;
    }
    
    /*
     * returns maximum power of two less than or equal to x
     */
    private int roundPowerTwo(int x)
    {
        if (x == 1)
            return 1;
        else 
            return roundPowerTwo(x/2)*2;
    }
    
    /*
     * true if there is at elast one node in the given region
     */
    private boolean hasRegion(int reg)
    {
        for (Tree.Node node : host.getNodes())
        {
            if (node.getRegion() == reg && reg != 0)
                return true;
        }
        return false;
    }
    
    /*
     * returns maximum region number;
     */
    private int maxRegion()
    {
        int max = 0;
        for (Tree.Node node : host.getNodes())
        {
            if (node.getRegion() > max)
                max = node.getRegion();
        }
        return max;
    }
            
    /*
     * allows user to input number of time zones first time time zone button is clicked
     * and  intial locations of time zone borders
     */
    public void timeZoneInit() {
        if (timeBorders.isEmpty())
        {
            int numTimeZones = 1;
            String timeNum = "1";
            boolean validInput = false;
            while (validInput == false)
            {
                timeNum = JOptionPane.showInputDialog("Number of Time Zones: ");
                
                if (timeNum != null)
                {
                    
                    try
                    {
                        numTimeZones = Integer.parseInt(timeNum);
                        
                        if (numTimeZones <= 1)
                        {
                            JOptionPane.showConfirmDialog(null, "Enter an integer greater than 1", "Invalid integer warning", JOptionPane.DEFAULT_OPTION);
                        }
                        
                        else
                        {
                            validInput = true;
                        }
                    }
                    
                    catch(NumberFormatException nfe)
                    {
                        JOptionPane.showConfirmDialog(null, "Enter an integer", "Non-integer warning", JOptionPane.DEFAULT_OPTION);
                    }
                }
                
                else
                    return;
            }
 
            //System.out.println("numTimeZones:" + numTimeZones);
            int numTimeBorders = 2 * (numTimeZones - 1); 
            float timeBorderX;
            for (int i=1; i<numTimeZones; i++)
            {
                timeBorderX = i*((getWidth()/2)/numTimeZones);
                timeBorders.add(timeBorderX);
                timeBorderX += getWidth()/2;
                timeBorders.add(timeBorderX);
            }
            Collections.sort(timeBorders);
            //System.out.println("timeBorders = " + timeBorders);
            for (Tree.Node node : host.getNodes())
            {
                for (int i=0; i<timeBorders.size(); i++)
                {
                    if (i == timeBorders.size()-1)
                    {
                        if (node.getX() >= timeBorders.get(i))
                        {
                            node.setMinTime(i+2);
                            node.setMaxTime(i+2);
                            break;
                        }
                    }
                    if (node.getX() >= timeBorders.get(i) && node.getX() < timeBorders.get(i+1))
                    {
                        node.setMinTime(i+2);
                        node.setMaxTime(i+2);
                        break;
                    }
                }
            }
            for (Tree.Node node : parasite.getNodes()) 
            {
                if (node.getX() < timeBorders.get(0)+getWidth()/2)
                {
                    node.setMinTime(numTimeZones);
                    node.setMaxTime(numTimeZones);
                }
                for (int i=0; i<numTimeZones-2; i++)
                {
                    if (node.getX() >= timeBorders.get(i)+getWidth()/2 && node.getX() < timeBorders.get(i+1)+getWidth()/2)
                    {
                        node.setMinTime(numTimeZones-1-i);
                        node.setMaxTime(numTimeZones-1-i);
                        break;
                    }
                }
            }
        }
        redoPanel();
    }
    
    /*
     * draws region key
     */
    private void drawRegKey(Graphics g) 
    {
        g.drawString("Region Key:", 20, 50);
        int maxRegion = maxRegion();
        int maxRow = maxRegion/7+1;
        panelDisp = 30*(maxRow+1);
        for (int i=1; i<maxRegion+1; i++)
        {
            if (hasRegion(i))
            {
                int row = i/7+1;
                setColor(i, g);
                g.fillOval(50+70*(i%7), 30*row+11, 2*radius, 2*radius);
                g.setColor(Color.BLACK);
                g.drawString(" = " + i, 65+70*(i%7), 30*row+20);
            }
        }
    }
    
    /*
     * draws region cost key
     */
    private void drawRegCostKey(Graphics g)
    {
       Graphics2D g2d = (Graphics2D) g;
       
       //deletes elements from regionCosts whose regions do not exist
       ArrayList<ArrayList<Double>> removeL = new ArrayList<ArrayList<Double>>(); 
       for (int i=0; i<regionCosts.size(); i++)
       {
            int startInt = regionCosts.get(i).get(0).intValue();
            int endInt = regionCosts.get(i).get(1).intValue();
            if (!hasRegion(startInt) || !hasRegion(endInt))
            {
                removeL.add(regionCosts.get(i));
            }
       }
       
       for (int i=0; i<removeL.size(); i++)
       {
           regionCosts.remove(removeL.get(i));
       }
           
       if (state == REGION_STATE && regionCosts.isEmpty()) 
       {
           g.drawString("Click here to add region switching costs", getWidth()/2+20, 50);
       }
       
       else if (!regionCosts.isEmpty())
       {
           g.drawString("Region Switching Costs: ", getWidth()/2+20, 55);
           for (int i=0; i<regionCosts.size(); i++)
           {
                int row = (i+1)/4+1;
                int rowTop = 30+40*(row-1); 
                        
                //writes region numbers
                int startInt = regionCosts.get(i).get(0).intValue();
                int endInt = regionCosts.get(i).get(1).intValue();
                String start = Integer.toString(startInt);
                String end = Integer.toString(endInt);
                int startX = getWidth()/2+80+120*((i+1)%4);
                int endX = getWidth()/2+140+120*((i+1)%4);
                g.drawString(start, startX, rowTop+21);
                g.drawString(end, endX, rowTop+21);
                
                //draw arrow
                g.setColor(Color.BLACK);
                g.drawLine(startX+9, rowTop+28, endX-4, rowTop+28);
                g.drawLine(endX-4, rowTop+28, endX-9, rowTop+23);
                g.drawLine(endX-4, rowTop+28, endX-9, rowTop+33);
                
                //writes cost 
                Double costD = regionCosts.get(i).get(2);
                if (costD == Double.POSITIVE_INFINITY)
                {
                    g.setColor(Color.RED);
                    BasicStroke thick = new BasicStroke(3.0f);
                    g2d.setStroke(thick);
                    g.drawLine((startX+endX)/2-2, rowTop+23, (startX+endX)/2+8, rowTop+33);
                    g.drawLine((startX+endX)/2-2, rowTop+33, (startX+endX)/2+8, rowTop+23);
                    g2d.setStroke(new BasicStroke());
                }    
                else 
                {
                    String costStr = Integer.toString(costD.intValue());
                    java.awt.geom.Rectangle2D rect = g.getFontMetrics().getStringBounds(costStr, g);
                    int textWidth = (int)(rect.getWidth());
                    int costX = (startX+endX)/2-textWidth/2+3;
                    g.drawString(costStr, costX, rowTop+25);
                }
                
                //draw nodes
                setColor(startInt, g);
                g.fillOval(startX-1, rowTop+23, 2*radius, 2*radius);
                setColor(Integer.parseInt(end), g);
                g.fillOval(endX-1, rowTop+23, 2*radius, 2*radius);
                g.setColor(Color.BLACK);
                
               if (panelDisp < rowTop+40)
               {
                   panelDisp = rowTop+40;
               }

           }
       }
    }
            
    
    /*
     * draws time zone arrows
     */
    private void drawArrows(Graphics g)  
    {
        for (Tree.Node node : host.getNodes())
        {
            //System.out.println("node.getMaxTime() = " + node.getMaxTime());
            if (node.getType() == Tree.INTERNAL_TYPE && node.getMinTime() != node.getMaxTime() && grabbedArrow != node)
            {
                //dragging time zone border near node from left
                if (dragging && grabbedBorder > 0 
                        && grabbedBorder < node.getX() && node.getX()-grabbedBorder < 35 
                        && (node.getMinTime() == borderIndex+2)) 
                {
                    int nodeX = node.getX();
                    int nodeY = node.getY() + panelDisp;
                    g.drawLine(nodeX-5, nodeY, nodeX-15, nodeY);
                    g.drawLine(nodeX-15, nodeY, nodeX-10, nodeY-5);
                    g.drawLine(nodeX-15, nodeY, nodeX-10, nodeY+5);

                    int highBorder;
                    if (node.getMaxTime() == timeBorders.size()/2+1)
                        highBorder = host.getLeaves().get(0).getX();

                    else
                        highBorder = (int)Math.round(timeBorders.get(node.getMaxTime()-1)) - 15;

                    g.drawLine(nodeX+5, nodeY, highBorder, nodeY);
                    g.drawLine(highBorder, nodeY, highBorder-5, nodeY-5);
                    g.drawLine(highBorder, nodeY, highBorder-5, nodeY+5);
                }
                
                //dragged time zone border past node from left
                else if (dragging && grabbedBorder > 0 && grabbedBorder >= node.getX() && node.getMinTime() == borderIndex+2)
                {
                    node.setMinTime(node.getMinTime()-1);
                }

                //non-dragged arrows covering range of time zones
                else
                {
                    int maxBorder;
                    int minBorder;

                    if (node.getMaxTime() == timeBorders.size()/2+1)
                        maxBorder = host.getLeaves().get(0).getX();
                    else
                        maxBorder = (int)Math.round(timeBorders.get(node.getMaxTime()-1)) - 15;

                    if (node.getMinTime() == 1)
                        minBorder = host.getRoot().getX();
                    else
                        minBorder = (int)Math.round(timeBorders.get(node.getMinTime()-2)) + 15;

                    int arrowX = node.getX();
                    int nodeY = node.getY() + panelDisp;
                    g.drawLine(arrowX+5, nodeY, maxBorder, nodeY);
                    g.drawLine(maxBorder, nodeY, maxBorder-5, nodeY-5);
                    g.drawLine(maxBorder, nodeY, maxBorder-5, nodeY+5);
                    g.drawLine(arrowX-5, nodeY, minBorder, nodeY);
                    g.drawLine(minBorder, nodeY, minBorder+5, nodeY-5);
                    g.drawLine(minBorder, nodeY, minBorder+5, nodeY+5);
                }
            }
        }
            
            for (Tree.Node node : parasite.getNodes())
        {
            if (node.getType() == Tree.INTERNAL_TYPE && node.getMinTime() != node.getMaxTime() && grabbedArrow != node)
            {
                //dragging time zone border near node from right
                if (dragging && grabbedBorder > 0 
                        && grabbedBorder > node.getX() && grabbedBorder-node.getX() < 35 
                        && (node.getMinTime() == timeBorders.size()-borderIndex+1)) 
                {
                    int nodeX = node.getX();
                    int nodeY = node.getY() + panelDisp;
                    g.drawLine(nodeX+5, nodeY, nodeX+15, nodeY);
                    g.drawLine(nodeX+15, nodeY, nodeX+10, nodeY-5);
                    g.drawLine(nodeX+15, nodeY, nodeX+10, nodeY+5);

                    int highBorder;
                    if (node.getMaxTime() == timeBorders.size()/2+1)
                        highBorder = parasite.getLeaves().get(0).getX();

                    else
                        highBorder = (int)Math.round(timeBorders.get(timeBorders.size()-node.getMaxTime())) + 15;

                    g.drawLine(nodeX-5, nodeY, highBorder, nodeY);
                    g.drawLine(highBorder, nodeY, highBorder+5, nodeY-5);
                    g.drawLine(highBorder, nodeY, highBorder+5, nodeY+5);
                }
                
                //dragged time zone border past node from right
                else if (dragging && grabbedBorder > 0 && grabbedBorder <= node.getX() && node.getMinTime() == timeBorders.size()-borderIndex+1)
                {
                    node.setMinTime(node.getMinTime()-1);
                }

                //non-dragged arrows covering range of time zones
                else
                {
                    int maxBorder;
                    int minBorder;

                    if (node.getMaxTime() == timeBorders.size()/2+1)
                        maxBorder = parasite.getLeaves().get(0).getX();
                    else
                        maxBorder = (int)Math.round(timeBorders.get(timeBorders.size()-node.getMaxTime())) + 15;

                    if (node.getMinTime() == 1)
                        minBorder = parasite.getRoot().getX();
                    else
                        minBorder = (int)Math.round(timeBorders.get(timeBorders.size()-node.getMinTime()+1)) - 15;

                    int arrowX = node.getX();
                    int nodeY = node.getY() + panelDisp;
                    g.drawLine(arrowX-5, nodeY, maxBorder, nodeY);
                    g.drawLine(maxBorder, nodeY, maxBorder+5, nodeY-5);
                    g.drawLine(maxBorder, nodeY, maxBorder+5, nodeY+5);
                    g.drawLine(arrowX+5, nodeY, minBorder, nodeY);
                    g.drawLine(minBorder, nodeY, minBorder-5, nodeY-5);
                    g.drawLine(minBorder, nodeY, minBorder-5, nodeY+5);
                }
            }
        }
        
        //draws node arrows for single time zone (only if in time state)
        if (state == TIME_STATE)
        {
            for (Tree.Node node : host.getNodes())
            {
                if (node.getType() == Tree.INTERNAL_TYPE && node.getMinTime() == node.getMaxTime() && grabbedArrow != node)
                {
                    int nodeX = node.getX();
                    int nodeY = node.getY() + panelDisp;
                    g.drawLine(nodeX+5, nodeY, nodeX+15, nodeY);
                    g.drawLine(nodeX+15, nodeY, nodeX+10, nodeY-5);
                    g.drawLine(nodeX+15, nodeY, nodeX+10, nodeY+5);        
                    g.drawLine(nodeX-5, nodeY, nodeX-15, nodeY);
                    g.drawLine(nodeX-15, nodeY, nodeX-10, nodeY-5);
                    g.drawLine(nodeX-15, nodeY, nodeX-10, nodeY+5);
                }
            }
            for (Tree.Node node : parasite.getNodes())
            {
                if (node.getType() == Tree.INTERNAL_TYPE && node.getMinTime() == node.getMaxTime() && grabbedArrow != node)
                {
                    int nodeX = node.getX();
                    int nodeY = node.getY() + panelDisp;
                    g.drawLine(nodeX+5, nodeY, nodeX+15, nodeY);
                    g.drawLine(nodeX+15, nodeY, nodeX+10, nodeY-5);
                    g.drawLine(nodeX+15, nodeY, nodeX+10, nodeY+5);        
                    g.drawLine(nodeX-5, nodeY, nodeX-15, nodeY);
                    g.drawLine(nodeX-15, nodeY, nodeX-10, nodeY-5);
                    g.drawLine(nodeX-15, nodeY, nodeX-10, nodeY+5);
                }
            }
        }
        
        //dragged arrows
        if (dragging && grabbedArrow != null) 
        {
            int arrowX = grabbedArrow.getX();
            int arrowY = grabbedArrow.getY() + panelDisp;

            //right arrow dragged
            if (arrowHead > grabbedArrow.getX()) 
            {
                g.drawLine(arrowX+5, arrowY, arrowHead, arrowY);
                g.drawLine(arrowHead, arrowY, arrowHead-5, arrowY-5);
                g.drawLine(arrowHead, arrowY, arrowHead-5, arrowY+5);

                int lowBorder=0;
                if (grabbedArrow.getMinTime() == grabbedArrow.getMaxTime()) //arrow opposite to dragged arrow short
                {
                    g.drawLine(arrowX-5, arrowY, arrowX-15, arrowY);
                    g.drawLine(arrowX-15, arrowY, arrowX-10, arrowY-5);
                    g.drawLine(arrowX-15, arrowY, arrowX-10, arrowY+5);
                }                   
                else //arrow opposite to dragged arrow long
                {
                    if (getSide(grabbedArrow.getX()) == Tree.HOST_TYPE)
                    {
                        if (grabbedArrow.getMinTime() == 1)
                            lowBorder = host.getRoot().getX();

                        else
                            lowBorder = (int)Math.round(timeBorders.get(grabbedArrow.getMinTime()-2)) + 15;
                    }
                    else
                    {
                        if (grabbedArrow.getMaxTime() == timeBorders.size()/2+1)
                            lowBorder = parasite.getLeaves().get(0).getX();
                        else
                            lowBorder = (int)Math.round(timeBorders.get(timeBorders.size()-grabbedArrow.getMaxTime())) + 15;
                    }

                    g.drawLine(arrowX-5, arrowY, lowBorder, arrowY);
                    g.drawLine(lowBorder, arrowY, lowBorder+5, arrowY-5);
                    g.drawLine(lowBorder, arrowY, lowBorder+5, arrowY+5);
                }
            }

            //left arrow dragged
            else
            {
                g.drawLine(arrowX-5, arrowY, arrowHead, arrowY);
                g.drawLine(arrowHead, arrowY, arrowHead+5, arrowY-5);
                g.drawLine(arrowHead, arrowY, arrowHead+5, arrowY+5);

                int highBorder=0;
                if (grabbedArrow.getMinTime() == grabbedArrow.getMaxTime()) //arrow opposite to dragged arrow short
                {
                    g.drawLine(arrowX+5, arrowY, arrowX+15, arrowY);
                    g.drawLine(arrowX+15, arrowY, arrowX+10, arrowY-5);
                    g.drawLine(arrowX+15, arrowY, arrowX+10, arrowY+5);
                }  

                else //arrow opposite to dragged arrow long
                {
                    if (getSide(grabbedArrow.getX()) == Tree.HOST_TYPE)
                    {
                        if (grabbedArrow.getMaxTime() == timeBorders.size()/2+1)
                            highBorder = host.getLeaves().get(0).getX();

                        else
                            highBorder = (int)Math.round(timeBorders.get(grabbedArrow.getMaxTime()-1)) - 15;
                    }
                    else
                    {
                        if (grabbedArrow.getMinTime() == 1)
                            highBorder = parasite.getRoot().getX();
                        else
                            highBorder = (int)Math.round(timeBorders.get(timeBorders.size()-grabbedArrow.getMinTime()+1)) - 15;
                    }

                    g.drawLine(arrowX+5, arrowY, highBorder, arrowY);
                    g.drawLine(highBorder, arrowY, highBorder-5, arrowY-5);
                    g.drawLine(highBorder, arrowY, highBorder-5, arrowY+5);
                }
            }
        }
    }
    
    
    /*
     * draws time zone borders
     */
    private void drawZones(Graphics g)
    {
        Graphics2D g2d = (Graphics2D) g;
        float dash[] = {20.0f, 20.0f};
        BasicStroke dashed = new BasicStroke (1.0f, BasicStroke.CAP_SQUARE, BasicStroke.JOIN_MITER, 10.0f, dash, 25.0f);
        g2d.setStroke(dashed);
        if (!timeBorders.isEmpty())
        {           
            // time zone 1 labels
            float first = timeBorders.get(0);
            
            if (first > 80)
                g.drawString("Time Zone 1", (int)Math.round(timeBorders.get(0)/2-40), panelDisp+20);
            
            else
            {
                g.drawString("Time", (int)Math.round(timeBorders.get(0)/2-18), panelDisp+20);
                g.drawString("Zone 1", (int)Math.round(timeBorders.get(0)/2-23), panelDisp+40);
            }
            g.drawString("1", (int)Math.round((getWidth() + timeBorders.get(timeBorders.size()-1))/2-3), panelDisp+20);
            
            // final time zone labels
            g.drawString(Integer.toString(timeBorders.size()/2+1), (getWidth()/2 + (int)Math.round(timeBorders.get(timeBorders.size()/2-1)))/2-3, panelDisp+20);
            g.drawString(Integer.toString(timeBorders.size()/2+1), (getWidth()/2 + (int)Math.round(timeBorders.get(timeBorders.size()/2)))/2-3, panelDisp+20);
            
            // final time zone lines
            g2d.draw(new Line2D.Double(timeBorders.get(timeBorders.size()/2-1), getHeight(), timeBorders.get(timeBorders.size()/2-1), panelDisp));
            g2d.draw(new Line2D.Double(timeBorders.get(timeBorders.size()/2), getHeight(), timeBorders.get(timeBorders.size()/2), panelDisp));
            
            // rest of host time zone lines and labels
            for (int i=0; i < timeBorders.size()/2-1; i++) 
            {
                g2d.draw(new Line2D.Double(timeBorders.get(i), getHeight(), timeBorders.get(i), panelDisp));
                g.drawString(Integer.toString(i+2), ((int)Math.round(timeBorders.get(i+1)+timeBorders.get(i))/2) - 3, panelDisp+20);
            }
            
            //rest of parasite time zone lines and labels
            for (int i=timeBorders.size()/2+1; i < timeBorders.size(); i++)
            {
                g2d.draw(new Line2D.Double(timeBorders.get(i), getHeight(), timeBorders.get(i), panelDisp));
                g.drawString(Integer.toString(timeBorders.size()-i+1), (int)Math.round(timeBorders.get(i-1)+timeBorders.get(i))/2-3, panelDisp+20);
            }
        }
        g2d.setStroke(new BasicStroke());
    }
    
    /*
     * draws links between leaves
     */
    private void drawLinks(Graphics g)
    {
        g.setColor(Color.CYAN); 
        Tree.Node linka;
        for (int i=0; i<links.size(); i++) {
            linka = links.get(i);
            for (Tree.Node linkb : linka.getLink()) {
                g.drawLine(linka.getX(), linka.getY()+panelDisp, linkb.getX(), linkb.getY()+panelDisp);
            }
        }
        if (dragX != -1 && state == LINK_STATE) //dragged link 
            g.drawLine(link1.getX(), link1.getY()+panelDisp, dragX, dragY);
    }
    
    /*
     * draws selection box for selecting nodes in region mode
     */
    private void drawBox(Graphics g)
    {
        Graphics2D g2d = (Graphics2D) g;
        if (clickedX < getWidth()/2 && clickedY > panelDisp && dragX != -1 && state == REGION_STATE)
        {
            g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.5f));
            g.setColor(Color.gray);
            int startX;
            int startY;
            
            if (dragY < panelDisp)
                dragY = panelDisp+1;
            
            if (dragX > getWidth()/2)
                dragX = getWidth()/2-1;
            
            if (clickedX < dragX)
                startX = clickedX;        
            else
                startX = dragX;
                        
            if (clickedY < dragY)
                startY = clickedY;
            else
                startY = dragY;
            
            g2d.fillRect(startX, startY, Math.abs(dragX-clickedX), Math.abs(dragY-clickedY));
            g.setColor(Color.darkGray);
            g2d.drawRect(startX, startY, Math.abs(dragX-clickedX), Math.abs(dragY-clickedY)); 
        }
    }
    
  
    private void paintHelper(Graphics g, Tree.Node current, int oldx) {
        /** Recursively paints a tree from the given root down */        
        //if current node is root, then draws to edge of window
        //Draw horizontal line from current node to previous level
        g.setColor(Color.BLACK); //changed from red
        g.drawLine(current.getX(), current.getY()+panelDisp, oldx, current.getY()+panelDisp);
        oldx = current.getX();

        //Find the y of the highest and lowest child and draw a vertical line
        //between these heights through the current node
        int miny = current.getY();
        int maxy = current.getY();
        
        
        ArrayList<Tree.Node> children = current.getChildren();
        for (int i=0; i < children.size(); i++) {
            if (children.get(i).getY() < miny)
                miny = children.get(i).getY();
            if (children.get(i).getY() > maxy)
                maxy = children.get(i).getY();
        }
        
        //lengthen the panel if necessary
        if (maxy > getHeight()) {
            this.setPreferredSize(new Dimension(getWidth(), maxy+50));
            this.setSize(getWidth(), maxy+50);
        }

        //draws verical line
        g.setColor(Color.BLACK); 
        g.drawLine(current.getX(), miny+panelDisp, current.getX(), maxy+panelDisp);

        //draws node
        int reg = current.getRegion();
        setColor(reg, g);
        g.fillOval(current.getX()-radius, current.getY()-radius+panelDisp, 2*radius, 2*radius);
        if (state != LINK_STATE)
        {
            linking = false;
            link1 = null;
        }
        if (linking) {
            g.setColor(Color.CYAN);
            g.fillOval(link1.getX()-radius, link1.getY()-radius+panelDisp, 2*radius, 2*radius);
        }

        //Attempt to draw label of node
        if (current.getType() == Tree.LEAF_TYPE)
        {
            g.setColor(Color.BLACK);
            JLabel currlabel = current.getLabel();
            String text = currlabel.getText();
            if (text.length()>0) 
            { 
                try
                {
                    Integer.parseInt(text);       
                }
                catch (NumberFormatException nfe)
                {       
                    if (current.getTreeType()==Tree.HOST_TYPE) 
                    {
                    FontMetrics metrics = g.getFontMetrics();
                    int width = metrics.stringWidth(text);
                    currlabel.setLocation(current.getX()-10-width, currlabel.getY());
                    }
                    g.drawChars(text.toCharArray(), 0, text.length(), currlabel.getX(),
                    currlabel.getY()+panelDisp);
                }
            }
        }

        //Recurse with all the children
        for (int i=0; i < children.size(); i++) {
            paintHelper(g, children.get(i), oldx);
        }
       
    }
    
    /*
     * sets color of node depending on region
     */
    private void setColor(int reg, Graphics g)
    {
        if (reg == 0)
            g.setColor(Color.BLUE);

        else
        {
            if (reg == 1)
                g.setColor(Color.GREEN);
            else if (reg == 2)
                g.setColor(Color.ORANGE);
            else if (reg == 3)
                g.setColor(Color.RED);
            else if (reg == 4)
                g.setColor(Color.GRAY);
            else if (reg == 10)
                g.setColor(Color.PINK);
            else
            {
                int power = roundPowerTwo(reg-4);
                float colorNum = ((float)1.0/(float)(2*power))+(float)((1.0/power)*(reg-4-power));
                g.setColor(Color.getHSBColor(colorNum, (float)1.0, (float)0.75));
            }
        }
    }
    
    /*
     * returns time zone of leaves 
     */
    private int leafTime()
    {
        if (!host.getLeaves().isEmpty())
            return host.getLeaves().get(0).getMaxTime();
        else if (!parasite.getLeaves().isEmpty())
            return parasite.getLeaves().get(0).getMaxTime();
        else
            return 1;
    }
    
    /*
     * makes .tree file output for links
     */
    public String makePhiOutput(int off)
    {
        String toReturn = "";
        for (int i = 0; i<links.size(); i++) 
        {
            Tree.Node current = links.get(i);
            if (current.getTreeType() == Tree.HOST_TYPE) 
            {
                toReturn += (host.getNodeID(current, 0)+"\t");
                for (Tree.Node linkedNode : current.getLink()) 
                {
                    
                    if (linkedNode == current.getLink().get(current.getLink().size()-1))
                        toReturn += parasite.getNodeID(linkedNode, off)+"\n";
                    else
                        toReturn += parasite.getNodeID(linkedNode, off)+"\t";
                }
            }
            
            else 
            {
                for (Tree.Node linkedNode : current.getLink())
                {
                    toReturn += (host.getNodeID(linkedNode, 0) + "\t");
                    toReturn += parasite.getNodeID(current, off) + "\n";
                }
            }
        }
        return toReturn;
    }
    
    /*
     * makes .tree file output for regions
     */
    public String makeRegionOutput()
    {
        String toReturn = "";
        for (Tree.Node node : host.getNodes())
        {
            toReturn += host.getNodeID(node, 0) + "\t" + node.getRegion() + "\n";
        }
        return toReturn;
    }
    
    /*
     * makes .tree file output for region costs
     */
    public String makeRegionCostOutput()
    {
        String toReturn = "";
        for (ArrayList<Double> cost : regionCosts)
        {
            if (cost.get(2) == Double.POSITIVE_INFINITY)
                toReturn += cost.get(0).intValue() + "\t" + cost.get(1).intValue() + "\t" + "infinity" + "\n";
            else
                toReturn += cost.get(0).intValue() + "\t" + cost.get(1).intValue() + "\t" + cost.get(2).intValue() + "\n";
        }
        return toReturn;
    }
    

    /**
     * 
     * @param filename
     * @throws IOException
     */
    public void saveTrees(String filename) throws IOException {
        FileOutputStream out;
        PrintStream file;
        
        out = new FileOutputStream(filename+".tree");
        file = new PrintStream(out);

        file.println("HOSTTREE");
        file.println(host.makeTreeOutput(0));

        file.println();

        file.println("HOSTNAMES");
        file.println(host.makeNameOutput(0));

        file.println();
        
        int offset = host.getSize();
        file.println("PARASITETREE");
        file.println(parasite.makeTreeOutput(offset));

        file.println();

        file.println("PARASITENAMES");
        file.println(parasite.makeNameOutput(offset));

        file.println();

        file.println("PHI");
        file.println(makePhiOutput(offset));

        file.println();

        file.println("HOSTRANKS");
        file.println(host.makeTimeOutput(0));

        file.println();

        file.println("PARASITERANKS");
        file.println(parasite.makeTimeOutput(offset));
        
        file.println();
        
        if (maxRegion() != 0)
        {
            file.println("HOSTREGIONS");
            file.println(makeRegionOutput());
        
            if (!regionCosts.isEmpty())
            {
                file.println("REGIONCOSTS");
                file.println(makeRegionCostOutput());     
            }
        }
        
        file.close();
    }

    /**
     * 
     * @param file
     * @throws IOException
     */
    public void loadTrees(File file) throws IOException {

        try {
            FileInputStream fstream = new FileInputStream(file);
            InputStreamReader f = new InputStreamReader(fstream);
            BufferedReader reader = new BufferedReader(f);

            ArrayList<String> hosttree = new ArrayList<String>();
            ArrayList<String> hostnames = new ArrayList<String>();
            ArrayList<String> paratree = new ArrayList<String>();
            ArrayList<String> paranames = new ArrayList<String>();
            ArrayList<String> linkings = new ArrayList<String>();
            ArrayList<String> hostranks = new ArrayList<String>();
            ArrayList<String> parasiteranks = new ArrayList<String>();
            ArrayList<String> hostregions = new ArrayList<String>();
            ArrayList<String> regioncosts = new ArrayList<String>();
            ArrayList<String> currlist = null;

            String line;
            while (reader.ready())
            {
                line = reader.readLine();
                if (line.toUpperCase().contains("HOSTTREE") )
                {
                    currlist = hosttree;
                }
                else if (line.toUpperCase().contains("HOSTNAMES") )
                {
                    currlist = hostnames;
                }
                else if (line.toUpperCase().contains("PARASITETREE") )
                {
                    currlist = paratree;
                }
                else if (line.toUpperCase().contains("PARASITENAMES") )
                {
                    currlist = paranames;
                }
                else if (line.toUpperCase().contains("PHI") )
                {
                    currlist = linkings;
                }
                else if (line.toUpperCase().contains("HOSTRANKS") )
                {
                    currlist = hostranks;
                }
                else if (line.toUpperCase().contains("PARASITERANKS") )
                {
                    currlist = parasiteranks;
                }
                else if (line.toUpperCase().contains("HOSTREGIONS") )
                {
                    currlist = hostregions;
                }
                else if (line.toUpperCase().contains("REGIONCOSTS") )
                {
                    currlist = regioncosts;
                }
                else {
                    line = line.replaceAll("\\s+", " ");
                    if (!line.equals(" ") && !line.equals(""))
                    {
                        System.out.println(line);
                        currlist.add(line);
                    }
                }
            }

            ArrayList<ArrayList<Integer>> htree = new ArrayList<ArrayList<Integer>>();
            String result[];
            for (int i=0; i<hosttree.size(); i++)
            {
                htree.add(new ArrayList<Integer>());
                result = hosttree.get(i).split(" ");
                for (int j=1; j<result.length; j++)
                {
                    try
                    {
                        htree.get(i).add(Integer.parseInt(result[j]));
                    }
                    catch (NumberFormatException nfe)
                    {
                        htree.get(i).add(0);
                    }
                }
            }

            ArrayList<ArrayList<Integer>> ptree = new ArrayList<ArrayList<Integer>>();

            for (int i=0; i<paratree.size(); i++)
            {
                ptree.add(new ArrayList<Integer>());
                result = paratree.get(i).split(" ");
                for (int j=1; j<result.length; j++)
                {
                    try
                    {
                        ptree.get(i).add(Integer.parseInt(result[j]));
                    }
                    catch (NumberFormatException nfe)
                    {
                        ptree.get(i).add(0);
                    }
                }
            }

            host = null;
            parasite = null;
            links = null;
            timeBorders.clear();
            regionCosts.clear();
            panelDisp = 0;

            host = new Tree(0, 0, getWidth()/2-5, getHeight(), Tree.HOST_TYPE);
            parasite = new Tree(getWidth()/2+5, 0, getWidth()/2-5, getHeight(),
                        Tree.PARASITE_TYPE);
            links = new ArrayList<Tree.Node>();

            loadTree(htree, hostnames, hostranks, hostregions, Tree.HOST_TYPE);
            ArrayList<Tree.Node> hostnodes = host.getNodes();
            int offset = hostnodes.size();

            ArrayList<Integer> current;
            for (int i=0; i<ptree.size(); i++)
            {
                current = ptree.get(i);
                for (int j=0; j<current.size(); j++)
                {
                    current.set(j, current.get(j)-offset);
                }
            }

            
            loadTree(ptree, paranames, parasiteranks, hostregions, Tree.PARASITE_TYPE);

            ArrayList<Tree.Node> paranodes = parasite.getNodes();

            int numTimeZones = leafTime();
            int numTimeBorders = 2*(numTimeZones-1); 
            float timeBorderX;
            for (int i=1; i<numTimeZones; i++)
            {
                timeBorderX = i*((getWidth()/2)/numTimeZones);
                timeBorders.add(timeBorderX);
                timeBorderX += getWidth()/2;
                timeBorders.add(timeBorderX);
            }
            Collections.sort(timeBorders);

            Tree.Node node1, node2;
            for (int i=0; i<linkings.size(); i++)
            {
                result = linkings.get(i).split(" ");
                node1 = hostnodes.get(Integer.parseInt(result[0])-1);
                for (int j=1; j<result.length; j++)
                {
                    node2 = paranodes.get(Integer.parseInt(result[j])-offset-1);
                    node1.addLink(node2);
                    node2.addLink(node1);
                    links.add(node1);
                }
            }
            
            String[] regionCost;
            for (int i=0; i<regioncosts.size(); i++)
            {
                regionCost = regioncosts.get(i).split(" ");
                ArrayList<Double> regionCostL = new ArrayList<Double>();
                for (int j=0; j<3; j++)
                {
                    if (regionCost[j].toLowerCase().equals("i") || regionCost[j].toLowerCase().equals("inf") || regionCost[j].toLowerCase().equals("infinity") || regionCost[j].toLowerCase().equals("infty"))
                    {
                        regionCostL.add(Double.POSITIVE_INFINITY);
                    }
                    else
                    {
                        double regionCostsIndex = Double.valueOf(regionCost[j]).doubleValue();
                        regionCostL.add(regionCostsIndex);
                    }
                }
                regionCosts.add(regionCostL);
            }
            
            redoPanel();
        }
        catch (IOException e) {
            throw e;
        }
        
    }

    private void loadTree(ArrayList<ArrayList<Integer>> tree, ArrayList<String> names, ArrayList<String> ranks, ArrayList<String> hostregions, int type) {
        
        Tree relTree;
        if (type == Tree.HOST_TYPE)
        {
            relTree = host;
        }
        else
        {
            relTree = parasite;
        }

        ArrayList<Tree.Node> nodes = relTree.getNodes();
        ArrayList<Integer> kids;
        String name[];
        String hostTime[];
        String paraTime[];
        String timeRange[];
        String region[];
        for (int i=0; i<tree.size(); i++)
        {
            for (int j=0; j<i; j++)
            {
                kids = tree.get(j);
                if (kids.contains(i+1))
                {
                    relTree.addChild(nodes.get(j));

                }
            }
            
            Tree.Node current = nodes.get(i);
            name = names.get(i).split(" ");
            current.setLabel(name[1]);
            
            hostTime = ranks.get(i).split(" "); 
            timeRange = hostTime[1].split(",");
            int minTime = Integer.parseInt(timeRange[0]);
            if (timeRange.length == 1)
            {
                current.setMinTime(minTime);
                current.setMaxTime(minTime);
            }
            
            else
            {
                int maxTime = Integer.parseInt(timeRange[1]);
                current.setMinTime(minTime);
                current.setMaxTime(maxTime);
            }
            
            if (type == Tree.HOST_TYPE)
            {
                region = hostregions.get(i).split(" ");
                int regionInt = Integer.parseInt(region[1]);
                current.setRegion(regionInt);
            }
            
        }
 
    }
    

//handles changes to panel   
private void redoPanel() {
    revalidate();
    repaint();
}

}

